(function(){"use strict";function N(r,s){if(r.length!==s.length)throw new Error("binary number A and B must have a same length");{let e=0;for(const t in r)r[t]!==s[t]&&r[t]!=="x"&&s[t]!=="x"&&e++;return e}}function M(r,s){return JSON.stringify([...r].sort())===JSON.stringify([...s].sort())}function O(r,s){const e=[];for(const t in r)r[t]===s[t]?e.push(r[t]):e.push("-");return e}function D(r,s){const e=[];for(const t of r){let o=0;for(const n of t)n==="0"&&o++;o===s&&e.push(t)}return e}function x(r,s){const e=[];for(const t of r){let o=0;for(const n of t)n==="1"&&o++;o===s&&e.push(t)}return e}function h(r,...s){for(const e of s)if(!r.includes(e))return!1;return!0}function y(r,s){let e=0;for(const t of s)t===r&&e++;return e}function p(r,s){let e=[...r.toString(2)];for(;e.length<s;)e=["0",...e];return e}function b(r){const s=[];for(let e=1;e<Math.pow(2,r.length);e++){const t=[],o=p(e,r.length);for(const n in o)o[n]==="1"&&t.push(r[n]);s.push(t)}return s.sort((e,t)=>e.length-t.length)}function g(r){let s=0;for(const e in r)s+=Math.pow(2,r.length-parseInt(e)-1)*parseInt(r[e]);return s}function I(r,s,e){const t=s.length,{minTerms:o,maxTerms:n,doNotCares:u}=P(r,t);if([...o,...u].length==Math.pow(2,t))return{equation:{functionName:r.name,terms:[{variables:["1"],supplement:!1,operator:e=="min-term"?"AND":"OR"}],operator:e=="min-term"?"OR":"AND"},table:{columns:[],solveMethod:e}};if(o.length==0)return{equation:{functionName:r.name,terms:[{variables:["0"],supplement:!1,operator:e=="min-term"?"AND":"OR"}],operator:e=="min-term"?"OR":"AND"},table:{columns:[],solveMethod:e}};let l,a,c,i,f,m;e=="min-term"?(l=d(o,u,t),a=B(l,t),c=T(a,t,e),i=w(c,o),f=A(i,o),m=R(f,r,s)):(l=d(n,u,t),a=E(l,t),c=T(a,t,e),i=k(c,n),f=q(i,n),m=F(f,r,s));const L={columns:c.columns.filter(S=>S.groupCells.filter(v=>v.cells.length>0).length>0),solveMethod:c.solveMethod};return{equation:m,table:L}}function P(r,s){const e=[],t=[],o=[];for(let n=0;n<Math.pow(2,s);n++)r.minTerms.includes(n)?e.push(n):r.doNotCares.includes(n)?o.push(n):t.push(n);return{minTerms:e,maxTerms:t,doNotCares:o}}function d(r,s,e){return[...r.map(t=>p(t,e)),...s.map(t=>p(t,e))]}function B(r,s){const e={numberOfDashes:0,groupCells:[]};for(let t=0;t<=s;t++){const o={numberOfTargetBit:t,cells:[]};for(const n of x(r,t))o.cells.push({MTOrDCNumbers:[g(n)],binaryNumber:n,matched:!1});e.groupCells.push(o)}return e}function E(r,s){const e={numberOfDashes:0,groupCells:[]};for(let t=0;t<=s;t++){const o={numberOfTargetBit:t,cells:[]};for(const n of D(r,t))o.cells.push({MTOrDCNumbers:[g(n)],binaryNumber:n,matched:!1});e.groupCells.push(o)}return e}function T(r,s,e){const t={columns:[r],solveMethod:e};for(let o=0;t.columns[t.columns.length-1].numberOfDashes<=s;o++){const n=t.columns[o],u={numberOfDashes:o+1,groupCells:[]};for(let l=0;l<n.groupCells.length-1;l++){const a=n.groupCells[l],c={numberOfTargetBit:a.numberOfTargetBit+1,cells:[]};for(const i of a.cells)for(const f of n.groupCells[l+1].cells)if(N(i.binaryNumber,f.binaryNumber)===1)if(c.cells.find(m=>M(m.MTOrDCNumbers,[...i.MTOrDCNumbers,...f.MTOrDCNumbers]))==null){const m={MTOrDCNumbers:[...i.MTOrDCNumbers,...f.MTOrDCNumbers],binaryNumber:O(i.binaryNumber,f.binaryNumber),matched:!1};i.matched=!0,f.matched=!0,c.cells.push(m)}else i.matched=!0,f.matched=!0;u.groupCells.push(c)}t.columns.push(u)}return t}function w(r,s){const e=[];for(const t of r.columns)for(const o of t.groupCells)for(const n of o.cells)if(!n.matched){const u=[];for(const l of n.MTOrDCNumbers)s.includes(l)&&u.push(l);u.length>0&&e.push({MTNumber:u,binary:n.binaryNumber})}return e}function k(r,s){const e=[];for(const t of r.columns)for(const o of t.groupCells)for(const n of o.cells)if(!n.matched){const u=[];for(const l of n.MTOrDCNumbers)s.includes(l)&&u.push(l);u.length>0&&e.push({MTNumber:u,binary:n.binaryNumber})}return e}function C(r){const s=[];for(const e of r)for(const t of e.MTNumber.filter(o=>!s.flatMap(n=>n.MTNumber).includes(o)))if(y(t,r.flatMap(o=>o.MTNumber))===1){s.push(e);break}return s}function A(r,s){const e=C(r),t=r.filter(n=>!e.includes(n)),o=b(t);for(const n of o)if(h([...e,...n].flatMap(u=>u.MTNumber),...s)){n.forEach(u=>e.push(u));break}return e}function q(r,s){const e=C(r),t=r.filter(n=>!e.includes(n)),o=b(t);for(const n of o)if(h([...e,...n].flatMap(u=>u.MTNumber),...s)){n.forEach(u=>e.push(u));break}return e}function R(r,s,e){const t={functionName:s.name,terms:[],operator:"OR"};for(let o=0;o<r.length;o++){const n={variables:[],supplement:!1,operator:"AND"};for(let u=0;u<r[o].binary.length;u++)switch(r[o].binary[u]){case"1":n.variables.push({name:e[u],supplement:!1});break;case"0":n.variables.push({name:e[u],supplement:!0});break}t.terms.push(n)}return t}function F(r,s,e){const t={functionName:s.name,terms:[],operator:"AND"};for(let o=0;o<r.length;o++){const n={variables:[],supplement:!1,operator:"OR"};for(let u=0;u<r[o].binary.length;u++)switch(r[o].binary[u]){case"1":n.variables.push({name:e[u],supplement:!0});break;case"0":n.variables.push({name:e[u],supplement:!1});break}t.terms.push(n)}return t}self.onmessage=r=>{const s=r.data.map(e=>I(e.logicalFunction,e.variables,e.solveMethod));postMessage(s)}})();
